记录一些待讨论的问题和一些原型中没有涉及到的细节:

1.所有的strategy应该有一个公共的接口类.

2.FileIO中,对于一些复杂的操作,例如LIST,不同的FS行为是不一致的,我们是仅在doc中提醒用户它们的行为可能有区别,还是说在方法入参中带入一些参数,
不同的参数组合表示体现出不同的行为,但是所有的FS实现必须行为一致. 

举个例子(所有的例子都在FileIO接口中),例如 `renameFile(URI src, URI dst,boolean overwrite)` 这个方法.
我们使用`boolean overwrite`这个表示来表示rename是否覆盖这种行为. 对于不同的OS,
要么抛出 UnsupportedOperatorException,要么按照预期实现.

再或者,`List<FileEntity> listAllFiles(URI path)`. 我们在这个方法中添加了一个doc,提示用户
这个方法对于不同的fs行为是不一致的.应在最小的范围内使用,以确保获得预期结果.

这两种,我们应该采用哪一种方案?或者说混合?

3.对于FS CATALOG,一个不可避免的问题是脏提交问题. 也就是说,我们总是可能成功提交一个旧的版本进入catalog.例如:IO缓慢.
如果此时IO出现中断,或者整个系统被KILL-9. 我们会不可避免地残留一些旧的脏提交相关的元数据文件.
我们是否应该尽最大努力清理它们,或者把他们放在一边不管就可以了,让用户自己去删除这种脏数据?
如果我们要清理,我们是在commit方法中清理,还是在别的什么地方?对于不同的fs,清理策略可能稍有区别,是否需要统一?如何统一?
如果我们不清理,理由是什么?请考虑一个1000张表的维护场景,是否会产生很大代价?

4.如何定义提交成功? 是写入HINT才算提交成功,还是说只要写入了最早的文件就算提交成功?
